```python
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from tqdm import tqdm

path = "E:\迅雷下载\iris\iris.csv"
pd.set_option('display.max_columns', None)
pd.set_option('display.max_rows', None)
pd.set_option('display.width', 5000)
iris = pd.read_csv(path)
# print(iris)
dummy = pd.get_dummies(iris['Species'])
# print(dummy)
iris = pd.concat([iris, dummy], axis =1 )
# print(iris)
iris = iris.iloc[0:100, :]
print(iris)
temp = pd.DataFrame(iris.iloc[:, 1:3])
label = np.array(pd.DataFrame(iris["setosa"][:100]))

# colors = np.where(iris["setosa"] == 1, 'r', 'k')
# iris.plot.scatter(x = "Sepal.Length",y = "Sepal.Width",c = colors)
train_x = np.array(temp)
# print(train_x)
numsamples, numfeatures = train_x.shape
# print((numsamples,numfeatures))


class logistic_regression():
    def __init__(self,dataset, eta, label, epochs,optimal):
        self.dataset = np.insert(dataset, 0, 1, axis=1)
#         print(self.dataset)
        self.label = label
        self.eta = eta
        self.epochs = epochs
        self.b = 0
        self.theta = np.insert(np.ones((dataset.shape[1],1)), 0, self.b, axis=0)
        self.optimal = optimal
    def sigmoid(self,x):
        return 1./(1+np.exp(-x))
    def calc_pred(self):
        pred = self.sigmoid(self.dataset.dot(self.theta))
#         print(f"pred = {pred}")
        return pred
    def calc_grad(self,pred):
        error = pred - self.label
#         print(f"error = {error}")
        grad = 1/self.dataset.shape[0]*self.dataset.T.dot(error)
#         print(f"grad = {grad}")
        return grad
    def bgd_update_theta(self,grad):
#         print(f"theta previous = {self.theta}")
        self.theta -= self.eta * grad
#         print(f"theta after = {self.theta}")
    def sgd_update_theta(self):
        for i in range(self.dataset.shape[0]):
            pred = self.sigmoid(self.dataset[i].dot(self.theta))
#             print(f"pred = {pred}")
            error_i = pred - label[i]
#             print(f"error_i = {error_i}")
            x_i = self.dataset[i][:,None]
#             print(f"dataset[i].T = {x_i},shape = {x_i.shape}")
            grad_i = 1/self.dataset.shape[0]*x_i.dot(error_i[None,:])
#             print(f"grad_i = {grad_i}")
            self.theta -= self.eta * grad_i
    def calc_loss(self,pred):
        l_theta = 0
#         print(f"pred = {pred}")
        for i in range(self.dataset.shape[0]):
            l_theta += self.label[i] * np.log(pred[i]) + (1-self.label[i]) * np.log(1-pred[i])
#         print(f"l_theta = {l_theta}")
        loss = -1/self.dataset.shape[0] * l_theta
#         print(f"loss = {loss}")
    def adagrad(self,epsilon = 1e-8):
        vt = np.zeros_like(self.theta)
        for i in range(self.dataset.shape[0]):
            pred_i = self.sigmoid(self.dataset[i].dot(self.theta))
            error_i = (pred_i - label[i])[None,:]
            x_i = self.dataset[i][:,None]
            grad_i = 1/self.dataset.shape[0]*x_i.dot(error_i)
            vt += grad_i**2
            self.theta -= self.eta * grad_i/(np.sqrt(vt + epsilon))
    def RMSProp(self,epsilon = 1e-8,decay_rate = 0.99):
        vt = np.zeros_like(self.theta)
        for i in range(self.dataset.shape[0]):
            pred_i = self.sigmoid(self.dataset[i].dot(self.theta))
            error_i = (pred_i - label[i])[None,:]
            x_i = self.dataset[i][:,None]
            grad_i = 1/self.dataset.shape[0]*x_i.dot(error_i)
            vt = decay_rate * vt + (1-decay_rate) * grad_i**2
            self.theta -= self.eta * grad_i/(np.sqrt(vt + epsilon))
    def Adam(self,epsilon = 1e-8, decay_rate1 = 0.9, decay_rate2 = 0.99):
        v = np.zeros_like(self.theta)
        m = np.zeros_like(self.theta)
        for i in range(self.dataset.shape[0]):
            pred_i = self.sigmoid(self.dataset[i].dot(self.theta))
            error_i = (pred_i - label[i])[None,:]
            x_i = self.dataset[i][:,None]
            grad_i = 1/self.dataset.shape[0]*x_i.dot(error_i)
#             print(f"grad_i = {grad_i}")
            m = decay_rate1 * m + (1 - decay_rate1) * grad_i
            v = decay_rate2 * v + (1 - decay_rate2) * (grad_i**2)
            m_t = m/(1 - decay_rate1 ** (i+1))
            v_t  = v/(1 - decay_rate2 ** (i+1))
#             print(f"m = {m}, v = {v}, m_t = {m_t}, v_t = {v_t}")
            self.theta -= self.eta * m_t / np.sqrt(v_t + epsilon)
#             print(self.theta)
    def fit(self):
        if self.optimal == "bgd":
            print("using bgd")
            for i in tqdm(range(self.epochs)):
#                 print(f"epoch {i}")
                pred = self.calc_pred()
                self.calc_loss(pred)
                grad = self.calc_grad(pred)
                self.bgd_update_theta(grad)
#                 print("\n")
        elif self.optimal == "sgd":
            print("using sgd")
            for i in tqdm(range(self.epochs)):
                self.sgd_update_theta()
        elif self.optimal == "adagrad":
            print("using adagrad")
            for i in tqdm(range(self.epochs)):
                self.adagrad()
        elif self.optimal == "RMSProp":
            print("using RMSProp")
            for i in tqdm(range(self.epochs)):
                self.RMSProp()
        elif self.optimal == "Adam":
            print("using Adam")
            for i in tqdm(range(self.epochs)):
                self.Adam()
    def predict(self,x):
        x = np.insert(x,0,1,axis = 1)
        h_x = x.dot(self.theta)
        y_pred = np.round(sigmoid(h_x))
        return y_pred.astype(int)

eta = 0.2
epochs = 1000
optimal = "adagrad"
k = logistic_regression(train_x,eta,label,epochs,optimal)
weight = k.theta
print(f"init theta = {weight}")
min_x = min(train_x[:,0])
max_x = max(train_x[:,0])
init_min_y = float(-weight[0]-weight[1]*min_x)/weight[2]
init_max_y = float(-weight[0]-weight[1]*max_x)/weight[2]
print(f"init x {(min_x,max_x)}, init y  = {(init_min_y,init_max_y)}")
plt.plot([min_x,max_x],[init_min_y,init_max_y],"-b")
k.fit()
weight = k.theta


for i in range(numsamples):
    if label[i] == 1:
        plt.plot(train_x[i][0], train_x[i][1],"or")
    elif label[i] == 0:
        plt.plot(train_x[i][0], train_x[i][1],"ob")
plt.xlabel("Sepal.Length")
plt.ylabel("Sepal.Width")

# print(min_x)

# print(max_x)
# min_x = min(train_x[:,0])
# max_x = max(train_x[:,0])
min_y = float(-weight[0]-weight[1]*min_x)/weight[2]
max_y = float(-weight[0]-weight[1]*max_x)/weight[2]
plt.plot([min_x,max_x],[min_y,max_y],"-g")
plt.show()


```

      5%|███▊                                                                           | 48/1000 [00:00<00:02, 475.15it/s]

        Unnamed: 0  Sepal.Length  Sepal.Width  Petal.Length  Petal.Width     Species  setosa  versicolor  virginica
    0            1           5.1          3.5           1.4          0.2      setosa       1           0          0
    1            2           4.9          3.0           1.4          0.2      setosa       1           0          0
    2            3           4.7          3.2           1.3          0.2      setosa       1           0          0
    3            4           4.6          3.1           1.5          0.2      setosa       1           0          0
    4            5           5.0          3.6           1.4          0.2      setosa       1           0          0
    5            6           5.4          3.9           1.7          0.4      setosa       1           0          0
    6            7           4.6          3.4           1.4          0.3      setosa       1           0          0
    7            8           5.0          3.4           1.5          0.2      setosa       1           0          0
    8            9           4.4          2.9           1.4          0.2      setosa       1           0          0
    9           10           4.9          3.1           1.5          0.1      setosa       1           0          0
    10          11           5.4          3.7           1.5          0.2      setosa       1           0          0
    11          12           4.8          3.4           1.6          0.2      setosa       1           0          0
    12          13           4.8          3.0           1.4          0.1      setosa       1           0          0
    13          14           4.3          3.0           1.1          0.1      setosa       1           0          0
    14          15           5.8          4.0           1.2          0.2      setosa       1           0          0
    15          16           5.7          4.4           1.5          0.4      setosa       1           0          0
    16          17           5.4          3.9           1.3          0.4      setosa       1           0          0
    17          18           5.1          3.5           1.4          0.3      setosa       1           0          0
    18          19           5.7          3.8           1.7          0.3      setosa       1           0          0
    19          20           5.1          3.8           1.5          0.3      setosa       1           0          0
    20          21           5.4          3.4           1.7          0.2      setosa       1           0          0
    21          22           5.1          3.7           1.5          0.4      setosa       1           0          0
    22          23           4.6          3.6           1.0          0.2      setosa       1           0          0
    23          24           5.1          3.3           1.7          0.5      setosa       1           0          0
    24          25           4.8          3.4           1.9          0.2      setosa       1           0          0
    25          26           5.0          3.0           1.6          0.2      setosa       1           0          0
    26          27           5.0          3.4           1.6          0.4      setosa       1           0          0
    27          28           5.2          3.5           1.5          0.2      setosa       1           0          0
    28          29           5.2          3.4           1.4          0.2      setosa       1           0          0
    29          30           4.7          3.2           1.6          0.2      setosa       1           0          0
    30          31           4.8          3.1           1.6          0.2      setosa       1           0          0
    31          32           5.4          3.4           1.5          0.4      setosa       1           0          0
    32          33           5.2          4.1           1.5          0.1      setosa       1           0          0
    33          34           5.5          4.2           1.4          0.2      setosa       1           0          0
    34          35           4.9          3.1           1.5          0.2      setosa       1           0          0
    35          36           5.0          3.2           1.2          0.2      setosa       1           0          0
    36          37           5.5          3.5           1.3          0.2      setosa       1           0          0
    37          38           4.9          3.6           1.4          0.1      setosa       1           0          0
    38          39           4.4          3.0           1.3          0.2      setosa       1           0          0
    39          40           5.1          3.4           1.5          0.2      setosa       1           0          0
    40          41           5.0          3.5           1.3          0.3      setosa       1           0          0
    41          42           4.5          2.3           1.3          0.3      setosa       1           0          0
    42          43           4.4          3.2           1.3          0.2      setosa       1           0          0
    43          44           5.0          3.5           1.6          0.6      setosa       1           0          0
    44          45           5.1          3.8           1.9          0.4      setosa       1           0          0
    45          46           4.8          3.0           1.4          0.3      setosa       1           0          0
    46          47           5.1          3.8           1.6          0.2      setosa       1           0          0
    47          48           4.6          3.2           1.4          0.2      setosa       1           0          0
    48          49           5.3          3.7           1.5          0.2      setosa       1           0          0
    49          50           5.0          3.3           1.4          0.2      setosa       1           0          0
    50          51           7.0          3.2           4.7          1.4  versicolor       0           1          0
    51          52           6.4          3.2           4.5          1.5  versicolor       0           1          0
    52          53           6.9          3.1           4.9          1.5  versicolor       0           1          0
    53          54           5.5          2.3           4.0          1.3  versicolor       0           1          0
    54          55           6.5          2.8           4.6          1.5  versicolor       0           1          0
    55          56           5.7          2.8           4.5          1.3  versicolor       0           1          0
    56          57           6.3          3.3           4.7          1.6  versicolor       0           1          0
    57          58           4.9          2.4           3.3          1.0  versicolor       0           1          0
    58          59           6.6          2.9           4.6          1.3  versicolor       0           1          0
    59          60           5.2          2.7           3.9          1.4  versicolor       0           1          0
    60          61           5.0          2.0           3.5          1.0  versicolor       0           1          0
    61          62           5.9          3.0           4.2          1.5  versicolor       0           1          0
    62          63           6.0          2.2           4.0          1.0  versicolor       0           1          0
    63          64           6.1          2.9           4.7          1.4  versicolor       0           1          0
    64          65           5.6          2.9           3.6          1.3  versicolor       0           1          0
    65          66           6.7          3.1           4.4          1.4  versicolor       0           1          0
    66          67           5.6          3.0           4.5          1.5  versicolor       0           1          0
    67          68           5.8          2.7           4.1          1.0  versicolor       0           1          0
    68          69           6.2          2.2           4.5          1.5  versicolor       0           1          0
    69          70           5.6          2.5           3.9          1.1  versicolor       0           1          0
    70          71           5.9          3.2           4.8          1.8  versicolor       0           1          0
    71          72           6.1          2.8           4.0          1.3  versicolor       0           1          0
    72          73           6.3          2.5           4.9          1.5  versicolor       0           1          0
    73          74           6.1          2.8           4.7          1.2  versicolor       0           1          0
    74          75           6.4          2.9           4.3          1.3  versicolor       0           1          0
    75          76           6.6          3.0           4.4          1.4  versicolor       0           1          0
    76          77           6.8          2.8           4.8          1.4  versicolor       0           1          0
    77          78           6.7          3.0           5.0          1.7  versicolor       0           1          0
    78          79           6.0          2.9           4.5          1.5  versicolor       0           1          0
    79          80           5.7          2.6           3.5          1.0  versicolor       0           1          0
    80          81           5.5          2.4           3.8          1.1  versicolor       0           1          0
    81          82           5.5          2.4           3.7          1.0  versicolor       0           1          0
    82          83           5.8          2.7           3.9          1.2  versicolor       0           1          0
    83          84           6.0          2.7           5.1          1.6  versicolor       0           1          0
    84          85           5.4          3.0           4.5          1.5  versicolor       0           1          0
    85          86           6.0          3.4           4.5          1.6  versicolor       0           1          0
    86          87           6.7          3.1           4.7          1.5  versicolor       0           1          0
    87          88           6.3          2.3           4.4          1.3  versicolor       0           1          0
    88          89           5.6          3.0           4.1          1.3  versicolor       0           1          0
    89          90           5.5          2.5           4.0          1.3  versicolor       0           1          0
    90          91           5.5          2.6           4.4          1.2  versicolor       0           1          0
    91          92           6.1          3.0           4.6          1.4  versicolor       0           1          0
    92          93           5.8          2.6           4.0          1.2  versicolor       0           1          0
    93          94           5.0          2.3           3.3          1.0  versicolor       0           1          0
    94          95           5.6          2.7           4.2          1.3  versicolor       0           1          0
    95          96           5.7          3.0           4.2          1.2  versicolor       0           1          0
    96          97           5.7          2.9           4.2          1.3  versicolor       0           1          0
    97          98           6.2          2.9           4.3          1.3  versicolor       0           1          0
    98          99           5.1          2.5           3.0          1.1  versicolor       0           1          0
    99         100           5.7          2.8           4.1          1.3  versicolor       0           1          0
    init theta = [[0.]
     [1.]
     [1.]]
    init x (4.3, 7.0), init y  = (array([-4.3]), array([-7.]))
    using adagrad
    

    100%|█████████████████████████████████████████████████████████████████████████████| 1000/1000 [00:02<00:00, 497.39it/s]
    


![png](output_0_3.png)



```python
a = np.array([[3],[2],[1]])
b = np.array([[3,2,1]])
print(f"a = {a}, shape = {a.shape}")
print(f"b = {b.T}, shape = {b.T.shape}")

```

    a = [[3]
     [2]
     [1]], shape = (3, 1)
    b = [[3]
     [2]
     [1]], shape = (3, 1)
    


```python
lst = [3,44,38,5,47,15,36,26,27,2,46,4,19,50,48]

def quicksort(arr):
    def partition(arr,left,right):
        key = left
        while left < right:
            while left < right and arr[right] >= arr[key]:
                right -= 1
            while left < right and arr[left] <= arr[key]:
                left += 1
            arr[right], arr[left] = arr[left], arr[right]
        arr[key],arr[left] = arr[left], arr[key]
        return left
    def sort(arr,left,right):
        if left >= right:
            return
        mid = partition(arr,left,right)
        sort(arr,left,mid-1)
        sort(arr,mid+1, right)
    if len(arr) <= 1:
        return arr
    left = 0
    right = len(arr) - 1
    sort(arr, left, right)
    return arr

quicksort(lst)
```




    [2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]




```python
lst = [3,44,38,5,47,15,36,26,27,2,46,4,19,50,48]


def heapify(arr,i,n):
    largest = i
    lchild = 2*i+1
    rchild = 2*i+2
    if lchild < n and arr[largest] < arr[lchild]:
        largest = lchild
    if rchild < n and arr[largest] < arr[rchild]:
        largest = rchild
    if largest != i:
        arr[largest], arr[i] = arr[i],arr[largest]
        heapify(arr, largest, n)
def heapsort(arr):
    if not arr:
        return
    n = len(arr)
    if n<=1:
        return arr
    for i in range(n,-1,-1):
        heapify(arr, i, n)
    for j in range(n-1,0, -1):
        arr[0], arr[j] = arr[j], arr[0]
        heapify(arr, 0, j)
    return arr

heapsort(lst)
```




    [2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]




```python
lst = [3,44,38,5,47,15,36,26,27,2,46,4,19,50,48]

def mergesort(arr):
    def msort(arr,left,right):
        if left >= right:
            return
        mid = left + (right-left)//2
        msort(arr, left, mid)
        msort(arr, mid+1, right)
        merge(arr, left, mid ,right)
    def merge(arr,left,mid,right):
        temp = []
        i = left
        j = mid + 1
        while i <= mid and j <= right:
            if arr[i] < arr[j]:
                temp.append(arr[i])
                i += 1
            else:
                temp.append(arr[j])
                j += 1
        while i <= mid:
            temp.append(arr[i])
            i += 1
        while j <= right:
            temp.append(arr[j])
            j += 1
        for i in range(left, right+1):
            arr[i] = temp[i - left]
    if not arr:
        return 
    if len(arr) == 1:
        return arr
    left = 0
    right = len(arr)-1
    msort(arr,left,right)
    return arr

mergesort(lst)
```




    [2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]




```python
arr = [1,2,3]

def permutation(arr):
    def backtrack(arr,size,depth,res,path,used):
        if depth == size:
            res.append(path[:])
            return
        for i in range(size):
            if not used[i]:
                if i > 0 and arr[i-1] == arr[i] and used[i-1] == False:
                    continue
                path.append(arr[i])
                used[i] = True
                backtrack(arr, size,depth+1,res,path,used)
                used[i] = False
                path.pop()
    if not arr:
        return
    n = len(arr)
    if n == 1:
        return arr
    res = []
    used = [False for _ in range(n)]
    backtrack(arr, n, 0, res, [], used)
    return res

permutation(arr)
```




    [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]




```python
a = "101"
b = "11"

def addBinary(a, b) -> str:
    print(int(a, 2))
    print(int(b, 2))
    return '{:b}'.format(int(a, 2) + int(b, 2))

addBinary(a, b)
```

    5
    3
    




    '1000'




```python
import numpy as np

a  = np.array([1,2,3])
print(a)
b = np.array([4,5,6])
print(b)
print(np.linalg.norm(a-b))
```

    [1 2 3]
    [4 5 6]
    5.196152422706632
    


```python
a = {"a":6,"b":5,"c":9}
tmp = sorted(a.items(),key = lambda x: x[1])
print(tmp[0][0])
```

    b
    


```python
a = [1,2,3]
a.reverse()
print(a)
```

    [3, 2, 1]
    


```python
class Solution:
    def mySqrt(self, x: int) -> int:
        left = 0
        right = x
        mid = left + (right - left)//2
        while 1:
            print(mid)
            tmp_ans = mid * mid
            if abs(x-tmp_ans) <= 0.0001:
                if (int(mid)+1) ** 2 == x:
                    return int(mid)+1
                else:
                    return int(mid)
            elif tmp_ans < x:
                left = mid
                mid = left + (right - left)/2
            elif tmp_ans > x:
                right = mid
                mid = left + (right - left)/2
                
k = Solution()
k.mySqrt(6)
```

    3
    1.5
    2.25
    2.625
    2.4375
    2.53125
    2.484375
    2.4609375
    2.44921875
    2.455078125
    2.4521484375
    2.45068359375
    2.449951171875
    2.4495849609375
    2.44940185546875
    2.449493408203125
    




    2




```python
import numpy as np

a = np.array([[1,2,3],[4,5,6]])
print(a)
b = np.array([[1,1,1],[2,2,2]])
print(np.average(b))
c = np.multiply(a,b)
print(c)
print(np.dot(a,b.T))
print(np.inner(a,b))
```

    [[1 2 3]
     [4 5 6]]
    1.5
    [[ 1  2  3]
     [ 8 10 12]]
    [[ 6 12]
     [15 30]]
    [[ 6 12]
     [15 30]]
    


```python
a = set("cde")
print(a)
b = set("cd")
print(b)
print(b.issubset(a))
```

    {'c', 'd', 'e'}
    {'c', 'd'}
    True
    


